[{"name":"Hlc","comment":" An implementation of hybrid logical clocks in Elm.\n\nYou can view the original paper [here](https://cse.buffalo.edu/tech-reports/2014-04.pdf).\n\n@docs Hlc, LocalHlc, RemoteHlc\n\n@docs create\n\n@docs local, remote\n\n@docs compare\n\n@docs toString, fromString\n\n@docs getPosix\n\n@docs values\n\n","unions":[{"name":"Hlc","comment":" A hybrid logical clock.\n\nThe constructor for this type is hidden. You can create a new clock with the `create`\nfunction in this module.\n\n","args":[],"cases":[]}],"aliases":[{"name":"LocalHlc","comment":" An alias for an `Hlc` representing the local clock.\n\nWhen used in this module, it's used to denote the difference between the local clock\nand a remote clock when those differences affect the outcome of a function.\n\n","args":[],"type":"Hlc.Hlc"},{"name":"RemoteHlc","comment":" An alias for an `Hlc` representing a remote clock.\n\nWhen used in this module, it's used to denote the difference between the local clock\nand a remote clock when those differences affect the outcome of a function.\n\n","args":[],"type":"Hlc.Hlc"}],"values":[{"name":"compare","comment":" Compare two hybrid logical clocks to determine their order.\n\nNote that the order of arguments is important! The first clock is being compared to the second.\nThe returned value will indicate if the first is greater than, less than, or equal\nto, the second.\n\nFor example, running:\n\n        const t = \"\"\n\n","type":"Hlc.Hlc -> Hlc.Hlc -> Basics.Order"},{"name":"create","comment":" Create a new hybrid logical-clock. To do so, you need a few pieces:\n\n  - A `String` represenging unique id for this transaction. In the case one clock is the\n    same as another clock, this will be used as a tiebreaker to determine which is greater.\n  - The curent time at the creation of a clock as `Posix` time. You will need to use the\n    [`elm/time`](https://package.elm-lang.org/packages/elm/time/latest/) library to get\n    this value.\n\nThat's it!\n\n","type":"String.String -> Time.Posix -> Hlc.Hlc"},{"name":"fromString","comment":" Attempts to take a string and turn it into a hybrid logical-clock.\n","type":"String.String -> Result.Result String.String Hlc.Hlc"},{"name":"getPosix","comment":" Get the `Posix` time for the passed clock.\n\nNote that if you reconstruct the clock from this returned `Posix` time, it is _not_ guaranteed to\ncreate the same clock. This is due to both the id and the count data being lost in the return\nvalue.\n\n","type":"Hlc.Hlc -> Time.Posix"},{"name":"local","comment":" When an action takes place locally and you want to increment the clock, use this\nfunction.\n\nThis will return a new clock that is guaranteed to result in a logical order of events\nmade on this machine, regardless of how accurate the clock on the machine is.\n\n","type":"String.String -> Time.Posix -> Hlc.LocalHlc -> Hlc.LocalHlc"},{"name":"remote","comment":" When an event is recieved from a remote source, this function can be used\nto increment the clock.\n\nNote: The order of arguments matters here; the first should be your local clock\nand the second is the remote clock. It's important to order these correctly. If\nyou do not, this function will return an unreliable clock.\n\n","type":"String.String -> Hlc.LocalHlc -> Hlc.RemoteHlc -> Time.Posix -> Hlc.Hlc"},{"name":"toString","comment":" Turn the clock into a string.\n\nThis string can use comparison operators (`==`, `>`, `<`, etc.) to determine what clock is\ngreater when comparing two clocks.\n\nRunning the following example:\n\n        Hlc.create \"unique-id\" (millisToPosix 1685853812)\n            |> Hlc.toString\n\nWill result in the following string representation of the clock:\n\n        \"000001685853812:00000000:unique-id\"\n\n","type":"Hlc.Hlc -> String.String"},{"name":"values","comment":" Return the values in a clock.\n\nThis is primarily used in testing the clock. It is not possible to reconstruct a clock from the\nreturned values.\n\n","type":"Hlc.Hlc -> { clock : Time.Posix, count : Basics.Int, id : String.String }"}],"binops":[]}]